# 第三章内存管理
**内存**=**系统区**+**内存区**

## 动态分区算法
1. **首次适应算法(First Fit)**：简称FF算法，空闲分区表按分区地址从小到大排序，从==头开始查找==，找到的首个合适的分区
2. **最佳适应算法**：空闲分区表按==分区大小**从小到大**排序==，从头开始查找，找到的首个合适的分区
3. **最坏适应算法**：空闲分区表按==分区大小从**大到小排序**==，从头开始查找，找到的首个合适的分区，即第一个分区（因为是从大到小排序，因此第一个必然是最大的空闲分区，若第一个都不满足，那后面的自然也不满足）
4. **==循环==首次适应算法**：简称FF算法，空闲分区表按分区地址从小到大排序，从==标记位开始查找==，找到的首个合适的分区


## 基本分页存储管理

**逻辑地址=页号+页内偏移量**

基本分页存储管理的思想：**把进程分页，各个页面可离散地放到各个内存块中**
基本概念
页框=内存块=页帧=物理块=物理页：内存中的块
页/页面：逻辑上的块，但是其大小与页框相等。

### 基本地址变换机构
页表寄存器（PTR）：存放页表在内存中的起始地址F和页表长度M,**进程未执行时会放在进程控制块（PCB）中**，进程被调度时，操作系统内核会把它们放到页表寄存器中
> 地址变换过程：
> 1. 根据逻辑地址算出页号，页内偏移量
> 2. 检查页号是否越界
> 3. 若页号合法则根据页表起始地址和页号找到对应页表项（==第一次访问内存—查页表==）
> 4. 根据页表项的内存块号、页内偏移量得到最终物理地址
> 5. 访问物理地址对应的物理单元（==第二次访问内存—访问目标单元==）

注：**页式管理**是**一维**的

 快表：又称联想寄存器（TLB），是一种访问速度比内存快很多的**高速缓存**，用来存放**最近频繁访问的页表项的副本**。
 
寄存器=>高速缓存(Cache)=>内存（RAM）=>外存

引入快表后**地址变换**的**不同**：
快表**命中**，则只需要**一次访存**
快表**未命中**，则仍需要**两次访存**（==第一次==访存查找==页表项==时，会同时==复制到快表==）

#### 局部性原理
**时间局部性**：若执行了程序中的某条指令，那么==不久后==这条指令==很可能==再次被==执行==。
**空间局部性**：一旦程序访问了某个存储单元，则==不久后附近的存储单元==也==很可能被访问==


TLB（快表）与Cache的区别：

|存储器件|TLB|Cache|
|----|----|----|
|区别|只有页表项的副本|可能还有其他各种数据的副本|

### 两级页表
#### 单级页表的问题
1. 页表必须连续存放，因此当页表很大时，需要占用很多连续的页框
2. 没必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面

一号页表（页目录表）->二号页表->页内偏移量

注意细节：
1. 多级页表机制下，**各级页表的大小不能超过一个页面**
2. 两级页表的访存次数为3次：
> - 第一次访存：页目录表
> - 第二次访存：二级页表
> - 第三次访存：访问目标内存单元
N级页表访问逻辑地址需要N+1次访存（无快表情况）

## 基本分段存储管理

**逻辑地址=段号+页内偏移量**

分段：按照程序**自身逻辑**关系**划分为若干个段**，每个段都有段名，**每段从0开始编址**，每个段在内存中占据连续空间，各段之间可以不相邻

1. 段号的位数决定了每个进程最多可以分几个段
2. 段内地址位数决定了每个段的最大长度是多少

### 段表
1. 由**段号**、**段长**、**基址**三部分组成
2. **各个段表项长度相同**，且段号可以是隐含的，不占存储空间。


## 分段与分页的区别
1. - **页**是信息的**物理单位**。分页的目的是为了实现离散存储，提高内存利用率。分**页**仅仅是系统管理需要，完全是**系统行为**，**对用户不可见**。
	- **段**是信息的**逻辑单位**，分段主要目的是更好地满足用户需求。一个段通常包含着一组属于逻辑模块的信息。**分段对用户是可见的**，用户编程时需要显式的给出段名。
2. **页的大小固定且由系统决定；段的长度不固定，取决于用户编写的程序**。
3. **分页**的用户进程**地址空间是一维**的，**分段**的用户进程**地址空间是二维**的
4. **分段**比分页**更容易实现信息的共享和保护**。（纯代码/可重入代码：不能被修改的代码）
5. 分页（单级页表）两次访存（页表->目标内存单元），分段两次方寸（段表->目标内存单元）

||优点|缺点|
|----|----|----|
|分页|内部空间利用率高，==不会产生外部碎片==，只有少量的页内碎片|不方便按逻辑模块实现信息的共享和保护|
|分段|方便安装逻辑模块实现信息的共享和保护|若段长过大，分配空间会很不方便。同时段式管理会==产生外部碎片==|

### 段页式管理

定义：先将进程按==逻辑分段==，然后再将==各个段分页==
**逻辑地址=段号+页号+页内偏移量**
**地址结构：二维**
段号：位数决定每个进程最多可以分几个段
页号：位数决定每个段最多能有多少页
页内偏移量：决定页面大小、内存块大小


段表结构：段号、==页表长度==、页表存放地址
页表结构：页号、页面存放地址


访存次数：3
第一次：查段表
第二次：查页表
第三次：查目标地址
若使用快表则只需要第三次

## 虚拟内存

```mermaid
graph TD
A[传统存储管理]
B[连续分配]
C[非连续分配]
B1[单一连续]
B2[固定分区]
B3[动态分区]
C1[基本分页存储]
C2[基本分段存储]
C3[基本段页式存储]
A==>B
A==>C
B==>B1
B==>B2
B==>B3
C==>C1
C==>C2
C==>C3
```

**一次性**：**作业必须一次性全部装入内存才能运行**
> 引起问题
> 1. 大作业很大时，无法全部装入，导致**大作业无法运行**
> 2. 大量作业要求运行时，由于内存无法容纳所有作业，因此只有少数作业能运行，==导致多道程序并发度下降==
**驻留性**：**作业 被装入后==一直驻留在内存中==**

提出背景：局部性原理


定义：
1. 将即将用到的部分装入内存，暂时未用到的部分留在外存
2. 信息不在内存时，操作系统从外存中调入内存
3. 内存空间不够时，暂时用不到的信息换出外存

特征：
- 多次性：多次调入内存
- 对换性：允许在作业运行时，将作业换入、换出
- 虚拟性：从逻辑上扩充了内存容量

虚拟内存技术基于离散存储技术。

```mermaid
graph TB
A[虚拟内存的实现]
B[请求分页存储]
C[请求分段存储]
D[请求段页式存储管理]
A==>B
A==>C
A==>D
```

主要区别：
1. 请求调页（段）功能：访问信息不在内存时，操作系统从外存调入内存
2. 页（段）面置换功能：内存不够时，不用的信息换出外存

### 请求分页存储技术

与基本分页存储主要区别：
1. 请求调页功能：访问信息不在内存时，操作系统从外存调入内存
2. 页面置换功能：内存不够时，不用的信息换出外存

```mermaid 
graph LR
A[请求分页管理]
B[页表机制]
C[缺页中断机构]
D[地址变换机构]
A==>B
A==>C
A==>D
```

#### 页表机制

页表结构：黄色部分为请求分页特有
- 内存块号
- ==状态位==：判断是否调入内存，0-未调入，1-已调入
- ==访问字段==：记录最近被访问过几次或时间
- ==修改位==：页面被调入后是否被修改
- ==外存地址==：页面在外存中存放位置


```mermaid
graph LR
A[中断]
B[内中断]
C[外中断]
B1[陷阱/陷入/trap]
B2[故障/fault]
B3[终止/abort]
C1[I/O中断请求]
C2[人工干预]
A==>B
A==>C
B==>B1
B==>B2
B==>B3
C==>C1
C==>C2
```

缺页中断为内中断

#### 缺页中断机构：
1. 找到页表项后检查页面是否在内存，**若没在内存，则产生缺页中断。**
2. 缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面
3. 缺页中断属于内中断，属于内中断中的“故障”，即可能呗系统修复的异常
4. 一条指令在执行过程中可能产生多次缺页中断

#### 地址变换机构不同点：
1. 找到页表项后需要**检查页面是否存在内存中**
2. **不在内存中，需要请求调页**
3. **内存空间不够**，需要**换出页面**
4. **页面调入内存后**，需要**修改相应页表项**

### 页面置换算法

```mermaid
graph LR
Z[页面置换算法]
A[最佳置换算法/OPT]
B[先进先出置换算法/FIFO]
C[最近最久未使用置换算法/LRU]
D[时钟置换算法/CLOCK]
E[改进型的时钟置换算法]
Z==>A
Z==>B
Z==>C
Z==>D
Z==>E
```

#### 最佳置换算法(OPT):
>定义：每次==淘汰的页面==将是==以后永不使用==，或者==在最长时间内不再被访问的页面==，从而==保证最低的缺页率==。
>- 但是实际上只有在进程执行的过程中才能知道接下来会访问到哪个页面。操作系统**无法提前预判页面访问序列**。因此==最佳置换算法是无法实现的==
缺页中断发生不一定发生页面置换，只有在页面满之后才会发生


#### 先进先出置换算法(FIFO)
> 定义：每次选择==淘汰的页面==是==最早进入内存的页面==
> 实现方式：队列
> 可能出现的异常：
> 1. ==Belady异常==：当为进程分配物理块数增大时，缺页次数不减反增的异常现象，只有FIFO才会出现这种异常
> 特点：
> 1. 实现简单
> 2. 算法性能差
> 3. 只有FIFO才会出现Belady异常
#### 最近最久未使用置换算法(LRU)
> 定义：每次==淘汰的页面==是==最近最久未使用的页面==
> 实现方式：赋予每个页面对应的页表项中，用==访问字段记录该页面自上次被访问以来所经历的时间t==
> 特点：
> 1. ==性能好==
> 2. 实现需要专门的硬件支持，==实现困难，开销大==

#### 时钟置换算法(CLOCK)
> 定义：一种性能和开销比较均衡的算法，又称CLOCK算法或最近未用算法（NRU）
> 实现方式：为每个页面设置一个==访问位==，再将内存中的页面都通过链接指针==链接成一个循环队列==。（1代表最近访问过，0代表最近未访问）
> 特点：
> 1. 简单的CLOCK算法选择一个淘汰页面==最多会经过两轮扫描==
#### 改进型的时钟置换算法
>定义：在其他条件相同时，应优先淘汰没有修改过的页面，避免I/O操作，设置一个修改位，1代表被修改过，0代表未被修改
>**算法规则**：==最多四轮==
>第一轮扫描：查找**（0,0）**的帧用于替换，且不修改任何标志位
>第二轮扫描：基于上一轮扫描失败，查找**（0,1）**的帧用于替换。且将所有扫描过的帧的访问位设置为0
>第三轮扫描：基于上一轮扫描失败，查找**（0,0）**的帧用于替换，且不修改任何标志位
>第四轮扫描：基于上一轮扫描失败，查找**（0,1）**的帧用于替换
注：由于第二轮已经将所有的帧的的访问位设为0，所以第三第四轮扫描一定会有帧被选择
淘汰优先级：
1. 没被访问且没被修改（0,0）
2. 没被访问但是被修改过的（0,1）
3. 访问过，但是没修改过（1,0）
4. 访问过也修改过（1,1）

| |算法规则|优缺点|
|----|----|----|
|OPT（最佳置换算法）|优先淘汰最长时间不会被访问的页面|缺页率小，性能最好，但无法实现|
|FIFO（先进先出算法）|优先淘汰最先进入内存的页面|实现简单；但性能很差，可能出现Belady异常|
|CLOCK(NRU)|循环淘汰各个页面，一轮淘汰访问位为0的，并将扫描过的页面访问位为1的设置为0。若一轮未选中，则进行二轮扫描|实现简单，但是算法开销小；单位考虑页面是否被修改过|
|改进型CLOCK（改进型NRU）|用（访问位，修改位）描述，则==一轮==：淘汰==（0,0）==；==二轮==：淘汰==（0,1）==，并将扫描页面的==访问位设置为0==；==三轮==：淘汰==（1,0）==;==四轮==：淘汰==（1,1）==|算法开销小，性能也不错|

### 页面分配策略
==驻留集==：请求分页存储管理中给进程分配的物理块的集合，其大小一般==小于进程的总大小==
- 驻留集太小：缺页频繁
- 驻留集太大L
<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyJaekdzMTFKdWQ3bmFyTGZBIjp7In
N0YXJ0IjoyMjk4LCJlbmQiOjIzMDIsInRleHQiOiLpobXooajp
lb/luqYifX0sImNvbW1lbnRzIjp7Im5lbjlhV3VYeHU0QlBYb0
giOnsiZGlzY3Vzc2lvbklkIjoiWnpHczExSnVkN25hckxmQSIs
InN1YiI6ImdoOjUzNTU4MTAwIiwidGV4dCI6IuWIhuauteeuoe
eQhuS4reS4uuauteihqOmVv+W6piIsImNyZWF0ZWQiOjE2Mzc4
MTMxNDI5NTB9fSwiaGlzdG9yeSI6WzE2MzU3OTQ0NzksMTMwNj
I4NDM0MywtMTU5MjY1NjE4NiwxNTg1NDA2ODIyLDk0MDc2NjU0
NywtMTI2OTQ5Nzk5MSwtNjUwMzM5MDMsMTk3MDU2NDY2NCwtNz
A2Nzk2MjIxLDE4NTczNzQ3NjYsMjMwNzA5NzU3LDY2ODI0MzA1
NiwtMTY2NTMwMjAzMiwxMDQwODU1MDkzLC0xNTc3MjI5NDE3LD
EwMDEwNzcyMTgsODc2MTQ3OTcwLDY2MzA5MDg2OCwxNTU3MzU1
Mzk0LC0xMjcyNjIzNTQwXX0=
-->